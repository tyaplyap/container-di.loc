# container-di.loc
Что такое «DI», «Container», «Auto-wiring»? На основе статьи Альберта Степанцева [@AlexLeonov](https://habr.com/ru/users/AlexLeonov/) 
на Хабр [Готовимся к собеседованию по PHP: Что такое «DI», «Container», «Auto-wiring» за семь простых шагов](https://habr.com/ru/post/655399/).

PHP 7.4

Задачи для раскрыия темы - принять  email, убедиться, что пользователь существует в бд и вывести его имя. Иначе выдать ошибку. 

Для проекта в базе данных создана таблица `user`.
Для реализации ORM названия столбцов таблицы соответсвуют названию свойств класса User, а значения являются значениям свойств в объектах класса User. 

id | name | email
---------- | --------- | -------
1 | Ivan | ivan@mail | 555
2 | Zakhar | zakhar@mail | 555

---
Каждый шаг оформлен отдельным коммитом. 

Зависимость - это объект, который необходим другому объекту для своей работы. 
Контроллеру нужен экземпляр класса репозитария, а репозитарию, в свою очередь, нужен объект доступа к базе данных класса Db.

**Step 1** 
Зависимость создается на лету, прям в методе того класса, где нам нужен объект другого класса. 
Другими словами, где нам понадобилась зависимость, там ее и создали. В результате код содержит в 
себе смесь бизнес-логики и логики получения зависимостей, и это всё в одном месте.

**Step 2**  
Разделим логику, когда мы получам зависимость и когда мы ее используем.  
Перепишем UserRepository и UserController таким образом, чтобы нужные им для работы объекты **передавились в них явно из вне**, 
а не создавались в их методах на лету. Для этого добавим в наши классы сеттеры, через которые будем передавать объект и 
добавим свойство, в которое будем записывать переданный объект.

Внедрение зависимостей (или Dependency Injection, сокращенно "DI") - явная передача зависимости в объект, который в 
ней нуждается извне. Вместо создания зависимости на лету, непосредественно там, где она нужна.


**Step 3**   
Обязательное внедрение зависимостей. Внедряем зависимость также явно, но уже через конструктор. 
Тогда зависимоть будет создаваться автоматически в момент создания объекта, а не вручную, через сеттер. 
Оба способа внедрения можно совмещать, но DI через конструктор - это способ по умолчанию.

**Step 4** 
Добавляем в проект контейнер. Контейнер - это очень простой паттерн. По сути дела это специальный объект, 
который умеет работать, как "key-value" хранилище для других объектов.

**Step 5** 
Сервисы. Объект, получаемый через контейнер и чьими зависимостями также управляет контейнер,  называют сервисом. 
Т.о.,  наши Db, UserRepository и UserController - это сервисы. И теперь контейнер занимается их "изготовлением", 
разрешением их зависимостей и "поставкой по требованию".

На 5-м шаге получим сервисы не по строковому идентификатору, а по полному имени их классов. 

**Step 6** 
Рефлексия. Добавляем рефлексию, подходим к концепции Autowiring. В конструкторе наших сервисов мы указали нужные 
зависимости, а имена этих зависимостей являются ключами объектов в контейнере. Теперь с помощью рефлексии мы можем 
автоматически получить сервис с внедренными в зависимостями. 

Перепишем наш контейнер таким образом, чтобы сохранить и "старый" механизм ленивого вызова функций, 
возвращающих сервисы, и "новый" - с авторазрешением зависимостей.

Теперь, чтобы в нашем приложении один сервис получил другой в качестве зависимости, достаточно будет просто 
указать тип зависимого сервиса в конструкторе нуждающегося. Это и есть автоматическое разрешение зависимостей, или **"auto-wiring"**

**Вопросы** 
Не понятно как быть с классом Db. В практике объект Db не создается через *new*, так как используется паттерн singleton. 
Объект создается через статический метод: $db = Db::getInstance();  

Как вариант, через рефлексию можно проверить является ли конструктор класса приватным. 
Если да, то проверяем, что существует метод getInstance(), что он статический и тогда вызываем его. 
